---
title: Catching spam with rspamd
lastUpdated: 2025-10-09
slug: ispmail-trixie/catching-spam-with-rspamd
sidebar:
  order: 300
---

import { Aside } from "@astrojs/starlight/components";

<Aside type="tip" title="Optional feature">
  This feature is completely optional. Just skip this page if you don't care about filtering out spam emails.
</Aside>

You have come a long way in this guide and your mail server is already fully functional. Now itâ€™s time to deal with the
dark side: spam. And there will be lots of it. So we need to detect spam emails and filter them out. I found that
[rspamd](https://rspamd.com/) is well-performing choice for that purpose both in speed and detection. rspamd keeps a
permanent process running on your mail server that listens to connections from Postfix using
theÂ [milter](http://www.postfix.org/MILTER_README.html)Â (=**m**ail f**ilter**) protocol. Every time an email enters your
system, Postfix will send it to rspamd to have its content checked. rspamd runs a lot of checks on the email and
computes a total score. The higher the score â€“ the more likely it it spam.

## How free is rspamd?

rspamd is quite effective against spam thanks to its many kinds of checks that incoming emails run through. Several of
these checks rely on services provided by the rspamd project. There are hosts like email.rspamd.com, uribl.rspamd.com
and maps.rspamd.com that provide information used by the default rspamd installation. That data is not freely available
and there are no public mirrors.

You are only allowed to use their data under certain conditions described in rspamdâ€™s
[usage policy](https://docs.rspamd.com/other/usage_policy/). Spoiler: heavy or commercial usage will get you blocked.
Your friends-and-family mail server with low volumes of email will probably be fine.

rspamd is being packaged and shipped by the Debian project. However the rspamd principal developer builds and endorses
his own packages and has a history of getting angry and offensive against anyone using the packages shipped by Debian. I
find that attitude a bit suspicious and rather stay with the Debian packages that have been built by a process that I
trust.

## Make Postfix use rspamd

Letâ€™s tell Postfix to send all incoming email through rspamd. Run these commands on the shell:

```
postconf smtpd_milters=inet:127.0.0.1:11332
postconf non_smtpd_milters=inet:127.0.0.1:11332
TODO: noâ€¦ postconf milter_mail_macros="i {mail_addr} {client_addr} {client_name} {auth_authen}"
```

Postfix will connect to rspamd that is listening to TCP port 11332 on localhost (127.0.0.1) and send the email through
that connection. The _smtpd_milters_ setting defines that connection for emails that came into the system from the
internet via the SMTP protocol. TheÂ *non_smtpd_milters* setting is optional â€“ it makes Postfix have all emails checked
that originate from the system itself. Finally theÂ *milter_mail_macros* setting defines several variables that rspamd
expects for better spam detection.Â rspamd then runs its checks and tells Postfix whether the email should pass or get
rejected.

## Testing spam detection

For testing we can use a sample spam email that comes with SpamAssassin. It is called GTUBE (GenericÂ Test
forÂ UnsolicitedÂ BulkÂ Email). It contains a certain artificial pattern that is recognized as spam by SpamAssassin. Do you
know EICAR.COM to test virus scanners? This is the same thing for spam.

I suggest that you download the file on the server and send it to John:

```sh
wget http://spamassassin.apache.org/gtube/gtube.txt
sendmail john@example.org < gtube.txt
```

Let's see what happened. Check your mail log:

```sh
journalctl -eu postfix
```

You will find something like this at the end:

```
postfix/pickup[1384784]: 2B72320126: uid=0 from=<root>
postfix/cleanup[1386519]: 2B72320126: message-id=<GTUBE1.1010101@example.net>
postfix/cleanup[1386519]: 2B72320126: milter-reject: END-OF-MESSAGE from localhost[127.0.0.1]: 5.7.1 Gtube pattern; from=<root@mailserver> to=<john@example.org>
postfix/cleanup[1386519]: 2B72320126: to=<john@example.org>, relay=none, delay=0.16, delays=0.16/0/0/0, dsn=5.7.1, status=bounced (Gtube pattern)
postfix/cleanup[1386525]: 4F0B720128: message-id=<20251009174553.4F0B720128@mailserver>
postfix/bounce[1386524]: 2B72320126: sender non-delivery notification: 4F0B720128
postfix/cleanup[1386519]: 2B72320126: removed (discarded)
```

**milter-reject** tells that the milter (rspamd) recommended to Postfix to reject the email. It gave the reason
`5.7.1 Gtube pattern`. In mail communication you often find these three digit codes. They are defined in
[RFC 3463](https://tools.ietf.org/html/rfc3463). The first digit is most important:

- 2 = Success
- 4 = Temporary failure (come back later)
- 5 = Permanent failure (do not try again in this way)

So `5.7.1` tells us that the result code is a permanent failure in delivery. If you looked up the RFC you would find
that the 7 stands for an issue regarding the security policy. So itâ€™s not a technical failure but instead a
security-relevant component on the system has rejected the email. Thatâ€™s what rspamd did. It even told us the reason:
`Gtube pattern`. So you see that rspamd knows about the Gtube spam test pattern and reacts as expected.

Accordingly you wonâ€™t see this email in Johnâ€™s inbox. This is a great advantage of using milters. Imagine Postfix
receiving a spam email and confirm its reception. What should it do when it finds out that itâ€™s unwanted email?
According to the SMTP protocol it must not throw away any emails. Would you create a bounce message telling the sender
that you did not accept the email? That would be a bad idea because the sender address in spam emails is very likely
forged. You would send the bounce to an innocent person thus creating so calledÂ *backscatter* and make it even worse. So
the better approach is to check the email while the sending server is still connected to your Postfix. This allows
Postfix to reject the email with a 5.x.x error code and let the other side figure out what to do.

## Score metrics

rspamd will however not reject all spam email. It computes a score that tells how likely a certain email is spam. You
can tell it which scores you would accept, flag as spam or make the incoming email get rejected. Rspamd has a large
ruleset that checks incoming emails in various ways and adds to the score. Take a look at the `/etc/rspamd/actions.conf`
file:

```
actions {
  reject = 15;
  add_header = 6;
  greylist = 4;
}
```

These are the default actions. If rspamd computes a score of at least 15 then the email will get rejected at the
doorstep just like the _Gtube pattern_ in the previous test. Any other score above 6 will add a line "X-Spam: Yes" so
that your mail software can detect them and maybe file the email to a different folder. And any other score above 4 will
trigger _greylisting_ which is a mechanism that temporarily rejects the email with a 4.x.x code and waits if the sending
server will try again. After a waiting time of a few minutes greylisting will accept the email. The idea is to reject
email from systems that do not have a sending queue. Malware like on infected Wind\*ws computers used to try sending an
email just once which triggered greylisting and successfully rejected the spammer. But even malware programmers have
learned and may try again after a few minutes thus circumventing greylisting. Your mileage may vary. The problem with
greylisting is that the recipient has to wait a couple of minutes for the email to be delivered which is often bothering
the users.

## X-Spam header

An email consists of **headers** and the actual **body**. Your users will usually only see common header information
like theÂ *subject*, theÂ *sender*, theÂ *recipient*Â and theÂ *time* the email was sent. But there is way more information
like the route the email travelled. Mail software can even add arbitrary **extended headers** that start with `X-`.
There is one specific header that rspamd adds for us if it finds a spam email:

```
X-Spam: Yes
```

<details class="collapsible">
  <summary>Click here to dive deeper into rspamd's scoresâ€¦</summary>

rspamd can add an `X-Spamd-Result` header containing the various criteria that added to the total score:

```
X-Rspamd-Server: mailserver
X-Rspamd-Queue-Id: C22E55A005B3
X-Spamd-Result: default: False [11.55 / 15.00]
 R_PARTS_DIFFER(0.27)[63.4%]
 FROM_NO_DN(0.00)[]
 RCVD_COUNT_ZERO(0.00)[0]
 R_DKIM_NA(0.00)[]
 FUZZY_DENIED(12.00)[1:19305c7fdd:1.00:bin,1:35699594fd:0.91:txt]
 RBL_SENDERSCORE(2.00)[55.181.23.94.bl.score.senderscore.com]
 ARC_NA(0.00)[]
 RCPT_COUNT_ONE(0.00)[1]
 RCVD_TLS_ALL(0.00)[]
 FROM_EQ_ENVFROM(0.00)[]
 R_SPF_SOFTFAIL(0.00)[~all]
 BAYES_HAM(-2.71)[98.75%]
 TO_MATCH_ENVRCPT_ALL(0.00)[]
 MIME_GOOD(-0.10)[multipart/related,multipart/alternative,text/plain]
 MID_RHS_MATCH_FROM(0.00)[]
 ASN(0.00)[asn:16276, ipnet:94.23.0.0/16, country:FR]
 TO_DN_NONE(0.00)[]
 DMARC_POLICY_SOFTFAIL(0.10)[Chronopost.fr : No valid SPF, No valid DKIM,none]
 SUBJECT_ENDS_EXCLAIM(0.00)[]
X-Spam: Yes
```

Enable those additonal headers:

```sh
cat > /etc/rspamd/local.d/milter_headers.conf << EOF
extended_spam_headers = true;
EOF
systemctl reload rspamd
wget http://spamassassin.apache.org/gtube/gtube.txt
swaks --server mailserver.example.org --to john@example.org --body @gtube.txt
```

What you just did:

- create a new file at `/etc/rspamd/local.d/milter_headers.conf` that extends rspamd's milter configuration
- restart rspamd to make it active
- get the GTUBE anti-spam test file (if you haven't already)
- send that spam test to John's email address. Please use your actual mail server name here instead of
  `mailserver.example.org`. It is important not to use `localhost` because rspamd will only add those headers for emails
  coming from the internet.

Each of the uppercase symbols likeÂ *FROM_HAS_DN* means that a certain detection rule of rspamd was triggered. It does
not necessarily mean something bad about the email. For example _R_SPF_ALLOW_ has a negative score that lowers the total
score because it is something good about the email. There are a several symbols with a 0.00 score. These do not change
the score but show you what rspamd has found. But if you consider certain criteria good or bad then you can
[define your own scores](https://docs.rspamd.com/configuration/metrics/#configuring-scores-and-actions) for them.

</details>

## Sending spam to the Junk folder

Your users will not realize that their spam emails have an added "X-Spam: Yes" header. It is not actively shown in their
mail client. Nor does it move the email out of the inbox into their spam folder. Such emails just appear like normal in
their inboxes. So letâ€™s aid them by automatically moving spam to a separate _Junk_ folder beneath their inbox.Â Dovecot
has support forÂ [Sieve](<https://en.wikipedia.org/wiki/Sieve_(mail_filtering_language)>) filtering rules that are simple
if-then scripts that run on the server automatically whenever an email comes in.

John could create a new Sieve filter (e.g. using the Roundcube webmail interface) for himself that would save any emails
to his "Junk" folder if the header line "X-Spam: Yes" was found. This rule would be useful for all your users though so
letâ€™s find a more general solution.

Dovecot supports _global_ Sieve filters that apply to all users. Let's do some preparation:

```sh
# Create a new config file for spam handling
cat > /etc/dovecot/conf.d/99-ispmail-sieve.conf << 'EOF'
sieve_script spam-to-junk-folder {
  driver = file
  type = after
  path = /etc/dovecot/sieve/spam-to-junk-folder.sieve
}

# Uncomment this line to get more verbose logs on sieve handling
# log_debug=category=sieve

# Enable Sieve rules when Postfix sends an email to Dovecot over LMTP
protocol lmtp {
  mail_plugins {
    sieve = yes
  }
}

# Make sure that the user has a Junk folder and is subscribed to it
namespace inbox {
  mailbox Junk {
    special_use = \Junk
    auto = subscribe
  }
}
EOF

# Restart Dovecot
systemctl reload dovecot

# Create the directory for Sieve files
mkdir -p /etc/dovecot/sieve

# Create the Sieve script to move Spam mails to the user's Junk folder
cat > /etc/dovecot/sieve/spam-to-junk-folder.sieve << 'EOF'
require ["fileinto"];

if header :contains "X-Spam" "Yes" {
 fileinto "Junk";
 stop;
}
EOF

# Compile the .sieve file into a .svbin file
sievec /etc/dovecot/sieve/spam-to-junk-folder.sieve
```

That was quite a lot. Let's quickly break it down:

1. You created a new config file at `/etc/dovecot/conf.d/99-ispmail-sieve.conf` to tell Dovecot thatâ€¦
   - before an email is delivered to the user, the `/etc/dovecot/sieve/spam-to-junk-folder.sieve` Sieve script is run
   - the Sieve functionality is enabled during LMTP (when an email is sent from Postfix to Dovecot)
   - the user get a _Junk_ folder created in his mailbox and is subscribed to it so that it appears in their mail
     program
2. The `/etc/dovecot/sieve` directory is created where we will put all Sieve-related files.
3. A Sieve script is put into `/etc/dovecot/sieve/spam-to-junk-folder.sieve` that will look for `X-Spam: yes` and then
   move the mail into the user's _Junk_ folder. The `require` line enables the `fileinto` command that would otherwise
   not be available.
4. The Sieve script is compiled into a binary file `spam-to-junk-folder.svbin` that Dovecot can work with.

Let's give it a test using Swaks. This time we impersonate Postfix and inject an email with an `X-Spam: yes` header
directly into Dovecot using the LMTP socket:

```sh
swaks --to john@example.org --header-X-Spam "yes" --socket /var/spool/postfix/private/dovecot-lmtp --protocol LMTP
```

Take a look at Dovecot's log:

```sh
journalctl -eu dovecot
```

It should read:

```
mailserver dovecot[1434406]: lmtp(1436598): Connect from local
mailserver dovecot[1434406]: lmtp(john@example.org)<1436598><kh4lDNl26Wi26xUA5ANL0g>: sieve: msgid=<20251010211257.1436597@mailserver>: fileinto action: stored mail into mailbox 'Junk'
mailserver dovecot[1434406]: lmtp(1436598): Disconnect from local: Logged out (state=READY)
```

<details class="collapsible">
  <summary>Click here to get more detailed logsâ€¦</summary>

If you find that the delivery to the _Junk_ folder did not work, you may want to increase the log level. Uncomment the
line

```
log_debug=category=sieve
```

in the `99-ispmail-sieve.conf` file.

That will give you a much deeper insight of what Dovecot has been doing. Restart Dovecot, send another email with
_swaks_ and check the logs again:

```sh
systemctl reload dovecot
journalctl -eu dovecot
```

</details>

The alleged spam email has been moved to the _Junk_ folder. Just like we wanted.

## About Redis

Many features in Rspamd use [Redis](https://redis.io/) to persist their data. Let me give you a quick explanation what
Redis is.

Redis is a kind of database system. It is way more limited than a traditional SQL database because it just stores keys
and values. There arenâ€™t several fields/columns like in SQL. But it is lightning fast the way it works. On my aged
server it handles around 50,000 requests per second. It gets it speed from its simplicity and from keeping the data in
RAM. So it doesnâ€™t access the disk to fetch information. (But it copies its data to disk frequently to prevent data
loss.) People use Redis as a cache or for very fast lookups of simple data structures. And so
[does rspamd](https://docs.rspamd.com/configuration/redis/).

## Enable auto-learning

One of rspamdâ€™s features is analyzing word patterns using probability theory. That functionality is contained in its
"[statistical module](https://rspamd.com/doc/configuration/statistic.html)". (Yes, the name is misleading.) Essentially
you show rspamd lots of ham (good) and spam (bad) emails and its detection gets better over time.

You have installed the "redis-server" package earlier. It has started automatically and listens to incoming connections
on TCP port 6379 on localhost. You just need to tell rspamd to use it:

```sh
# Create a config file to enable automatic spam training
cat > /etc/rspamd/local.d/classifier-bayes.conf << 'EOF'
# Store training data in the Redis database
servers = "127.0.0.1:6379";
backend = "redis";

# Enable automatic training
autolearn = true;   # if rspamd is sure that an email is spam, it will be learned
min_learns = 200;   # do not trust the data before at least 200 mails have been learned
EOF

# Restart rspamd
systemctl restart rspamd
```

You can start with an empty training database. This is not as bad as it sounds. rspamd checks many properties of an
email to determine if an email is ham or spam. Autolearning takes email that are likely ham or spam and uses them to
train the spam filter. TheÂ [rspamd documentation](https://rspamd.com/doc/configuration/statistic.html) has further
examples how to fine-tune auto learning. After a few hundred emails the training will contribute towards a better
detection rate.

The defaults for auto-learning are:

- score &lt; -0.5 âžž learn as ham/good
- score &gt; 4.0 âžž learn as spam/bad

See [rspamd's documentation](https://docs.rspamd.com/configuration/statistic/#statistics-configuration) if you want to
fine-tune that.

```
rspamc stat
```

Bayes spam checking will not work before it learned at least 200 spam and ham emails. Teaching rspamd fewer emails or
just spam emails will not work. This is defined by theÂ *min_learns* variable defined in /etc/rspamd/statistic.conf.

In the output you will find lines beginning with "Statfile" like theseâ€¦

```
Statfile: BAYES_SPAM type: redis; length: 0; free blocks: 0;
    total blocks: 0; free: 0.00%; learned: 21164;
    users: 214; languages: 0

Statfile: BAYES_HAM type: redis; length: 0; free blocks: 0;
    total blocks: 0; free: 0.00%; learned: 1411;
    users: 62; languages: 0
```

This is what you usually start with. The more emails you feed into the training process the better the detection rate
will be. Some emails however may not be long enough or too similar to previously trained emails. So donâ€™t worry if you
are training 1000 emails but just get a count of 500 emails here.

## Per-user spam training

rspamd allows you to train the spam detection per user. It would not keep a global training database that applies to all
users. Instead each user gets their own training.

Advantage: users work differently. Some have subscribed to a sales newsletter and now believe that marking it as spam
gets them unsubscribed. Yes, thatâ€™s stupid but can thoroughly confuse the spam detection. Also you might be very
interested in viagr\* product information while others do not.

Disadvantage: training still requires many ham and spam mails before it has any effect. So unless a user gets 200
samples of good and evil emails the spam detection cannot work. Many users will not get that many emails so due to the
lack of spam training the detection will not be improved.

If you decide you want to use per-user spam training then add/edit the file `/etc/rspamd/local.d/classifier-bayes.conf`
and insert:

```
users_enabled = true;
```

## Autoexpunge

Andi Olsen pointed out that Dovecot has introduced a [feature](https://wiki.dovecot.org/MailboxSettings) to
automatically delete emails in a folder that reach a certain age. This is especially useful for the "Trash" and "Junk"
folders. To enable this feature just edit theÂ `/etc/dovecot/conf.d/15-mailboxes.conf` file and add theÂ *autoexpunge*
parameter where desired. Example:

```
mailbox Junk {
  special_use = \Junk
  auto = subscribe
  autoexpunge = 30d
}
mailbox Trash {
  special_use = \Trash
  auto = subscribe
  autoexpunge = 30d
}
```

The "auto = subscribe" makes sure that the "Junk" and "Trash" folders are automatically created for every user.
Otherwise spam emails cannot be moved to the "Junk" folder later.

## Learning from user actions

Now we are getting to something really cool. Letâ€™s tell Dovecot that moving emails into the Junk folder teaches rspamd
instantly that the email is spam. And train an email as ham if it is moved out of the Junk folder. We will add triggers
(actually "_sieve scripts_") to the action of moving emails via IMAP.

The currently recommended way is to use the
"[IMAPSieve](https://doc.dovecot.org/2.3/settings/pigeonhole-ext/imapsieve/)" plugin instead. There is nothing to
install â€“ it comes with the Dovecot packages. We just need to configure it.

First order of business is enabling the IMAPSieve plugin for the IMAP protocol/service in Dovecot. Edit the
`/etc/dovecot/conf.d/20-imap.conf` file and look for the line reading "mail_plugins". Turn it into:

```
mail_plugins = $mail_plugins quota imap_sieve
```

We also need to edit Dovecotâ€™s Sieve configuration to enable two plugins that are required for our task. Sieve is a
scripting language that automates things in conjunction with emails and folders. Edit the
fileÂ `/etc/dovecot/conf.d/90-sieve.conf` and put these lines into the `plugin {â€¦}` section:

```
# From elsewhere to Junk folder
imapsieve_mailbox1_name = Junk
imapsieve_mailbox1_causes = COPY
imapsieve_mailbox1_before = file:/etc/dovecot/sieve/learn-spam.sieve

# From Junk folder to elsewhere
imapsieve_mailbox2_name = *
imapsieve_mailbox2_from = Junk
imapsieve_mailbox2_causes = COPY
imapsieve_mailbox2_before = file:/etc/dovecot/sieve/learn-ham.sieve

sieve_pipe_bin_dir = /etc/dovecot/sieve
sieve_global_extensions = +vnd.dovecot.pipe
sieve_plugins = sieve_imapsieve sieve_extprograms
```

The first rule tells Dovecot to run the Sieve rules as defined in theÂ `/etc/dovecot/sieve/learn-spam.sieve` file
whenever an email is moved into a userâ€™s "Junk" folder. We will create that Sieve script in a minute.

The second rule sets the other way. Whenever an email is movedÂ from the "Junk" folder to any (\*) folder then
theÂ `/etc/dovecot/sieve/learn-ham.sieve` Sieve script is called.

The "sieve_pipe_bin_dir" setting defines where executable scripts are allowed to reside. We will put our simple learning
scripts there. And finally the "sieve_global_extensions" setting enables the pipe plugin that allows sending email to
external commands.

Next up letâ€™s create the Sieve scripts that we told Dovecot about. Create a new directory /etc/dovecot/sieve to put our
new files in:

```
mkdir /etc/dovecot/sieve
```

Then create the fileÂ `/etc/dovecot/sieve/learn-spam.sieve` and let it contain:

```
require ["vnd.dovecot.pipe", "copy", "imapsieve"];
pipe :copy "rspamd-learn-spam.sh";
```

Letâ€™s do the same forÂ `/etc/dovecot/sieve/learn-ham.sieve`

```
require ["vnd.dovecot.pipe", "copy", "imapsieve", "variables"];
if string "${mailbox}" "Trash" {
  stop;
}
pipe :copy "rspamd-learn-ham.sh";
```

The above Sieve script avoids training an email as _ham_ if the user moves it to the _Trash_ folder. After all if you
clear your _Junk_ folder you do not want to train your spam as regular emails.

Restart Dovecot:

```
systemctl restart dovecot
```

These two scripts need to be compiled â€“ that is turning them into machine-readable code:

```
sievec /etc/dovecot/sieve/learn-spam.sieve
sievec /etc/dovecot/sieve/learn-ham.sieve
```

This creates two new files "learn-ham.svbin" and "learn-spam.svbin" that look like gibberish inside but are now in a
format that Dovecotâ€™s Sieve plugin can understand.

Letâ€™s fix the permissions of these files, too, while we are at it:

```
chmod u=rw,go= /etc/dovecot/sieve/learn-{spam,ham}.{sieve,svbin}
chown vmail:vmail /etc/dovecot/sieve/learn-{spam,ham}.{sieve,svbin}
```

And the last step is to create the simple shell scripts that do the actual spam/ham training. The first file is
`/etc/dovecot/sieve/rspamd-learn-spam.sh` which contains:

```
#!/bin/sh
exec /usr/bin/rspamc learn_spam
```

That looks simple, doesnâ€™t it? Nothing more is actually needed. The spam email is piped to this script and rspamd learns
it as a spam email and adjusts its spam detection database accordingly.

The second script teaches ham and is calledÂ `/etc/dovecot/sieve/rspamd-learn-ham.sh`. Make it contain:

```
#!/bin/sh
exec /usr/bin/rspamc learn_ham
```

These two shell scripts must be made executable:

```
chmod u=rwx,go= /etc/dovecot/sieve/rspamd-learn-{spam,ham}.sh
chown vmail:vmail /etc/dovecot/sieve/rspamd-learn-{spam,ham}.sh
```

I hope you havenâ€™t lost your mind yet. Itâ€™s really just a chain of things to happen. Letâ€™sÂ reiterate how this process
works:

1. a user moves a spam email into their "Junk" folder
2. Dovecot realizes that this triggers the Sieve rule "imapsieve_mailbox1" so it calls the Sieve
   scriptÂ /etc/dovecot/sieve/learn-spam.sieve (in fact the \*.svbin version of the script)
3. Sieve will take the email and send ("pipe") it to the executableÂ rspamd-learn-spam.sh shell script
4. the script in turn runs the email through the "/usr/bin/rspamc learn_spam" command

This works equally for the other way or learning ham emails of course.

I am sure you are eager to try it out. However to see that it actually works I suggest you edit
theÂ /etc/dovecot/conf.d/10-logging.conf file and set "mail_debug=yes". That will add a lot more detail to the
/var/log/mail.log file but on a busy server may also lead to headaches. ðŸ™‚

Restart Dovecotâ€¦

```
systemctl restart dovecot
```

â€¦and watch the /var/log/mail.log fileâ€¦

```
tail -f /var/log/mail.log
```

Now open your IMAP client (Thunderbird, Evolution, Roundcube, mutt or whatever you prefer) and drag an email to your
Junk folder. The mail log will show a lot of things that are going on. I tried to compact the output so that you better
understand that it worked:

```
imapsieve: Static mailbox rule [1]: mailbox=`Junk' from=`*' causes=(COPY) => before=`file:/etc/dovecot/sieve/learn-spam.sieve' after=(none)
imapsieve: Static mailbox rule [2]: mailbox=`*' from=`Junk'
    causes=(COPY) => before=`file:/etc/dovecot/sieve/learn-ham.sieve'
    after=(none)

imapsieve: Matched static mailbox rule [1]

sieve: file storage: script: Opened script `learn-spam'
    from `/etc/dovecot/sieve/learn-spam.sieve'

sieve: action pipe: running program: rspamd-learn-spam.sh

program exec:/etc/dovecot/sieve/rspamd-learn-spam.sh:
    Pass environment: USER=john@example.org

program exec:/etc/dovecot/sieve/rspamd-learn-spam.sh:
    Pass environment: HOME=/var/vmail/example.org/john

program exec:/etc/dovecot/sieve/rspamd-learn-spam.sh:
    Pass environment: HOST=narnia

Mailbox Junk: UID 1: Opened mail because: mail stream

sieve: uid=1: Execute storing into mailbox 'Junk'
```

Dovecot finds two Sieve rules: \[1\] and \[2\]. And it finds that rule \[1\] matches your current action and runs it.
That in turn calls the "rspamd-learn-spam.sh" script to train that email as spam. And at the very end the email is
actually moved to the "Junk" folder.

And if you pull an email out of the "Junk" folder you should see mailbox rule \[2\] be called and the email being
learned as ham.

Donâ€™t forget to switch off "mail_debug" again or your usersâ€™ actions will quickly fill your log file.

## Logging

rspamd keeps a verbose log of its actions in /var/log/rspamd/rspamd.log. If a user complains that a certain email got
blocked or at least flagged as spam then take a look at this log. You can match the /var/log/mail.log with it by
comparing the Postfix queue ID. Those are the 12-digit hexadecimal number like "**95CE05A00547**". Those IDs can be
found in the rspamd.log, too:

```
<40985d>; task; rspamd_task_write_log: id: <undef>, qid: <**95CE05A00547**>,  ip: 12.13.51.194, from: <â€¦>, (default: F (no action):  [3.40/15.00]  [MISSING_MID(2.50){},MISSING_DATE(1.00){},MIME_GOOD(-0.10){text/plain;},ARC_NA(0.00){},ASN(0.00){asn:8220,  ipnet:212.123.192.0/18,  country:GB;},FROM_EQ_ENVFROM(0.00){},FROM_NO_DN(0.00){},RCPT_COUNT_ONE(0.00){1;},RCVD_COUNT_ZERO(0.00){0;},RCVD_TLS_ALL(0.00){},TO_DN_NONE(0.00){},TO_DOM_EQ_FROM_DOM(0.00){},TO_MATCH_ENVRCPT_ALL(0.00){}]),  len: 181, time: 16.000ms real, 6.385ms virtual, dns req: 0, digest:  <69b289a82827c11f759837c033cd800a>, rcpts: <â€¦>, mime_rcpt:  <â€¦>
```

## The web interface

rspamd comes with a neat bonus feature: a web interface. It allows you to check emails for spam, get statistics and
fine-tune scores. It is already installed and enabled by default and expects HTTP requests on port 11334 on the
localhost interface. I suggest you add a simple proxy configuration to your already working HTTPS-enabled web mail
configuration to get access.

![rspamd dashboard](images/catching-spam-rspamd-dashboard.png)

First you need to enable Apacheâ€™s modules for HTTP proxying and rewriting:

```
a2enmod proxy_http
a2enmod rewrite
```

You can either create a new virtual host configuration or just edit the
/etc/apache2/sites-available/webmail.**example.org**-https.conf file. Anywhere within theÂ *VirtualHost* tags add:

```
<Location /rspamd>
  Require all granted
</Location>

RewriteEngine On
RewriteRule ^/rspamd$ /rspamd/ \[R,L\]
RewriteRule ^/rspamd/(.\*) http://localhost:11334/$1 \[P,L\]
```

This piece of configuration will forward any requests to `https://webmail.example.org/rspamd` to localhost:11334 and
thus give you access to the rspamd web interface.

The interface is password protected. Letâ€™s generate a new access password:

```
pwgen 15 1
```

This gives you a password like "eiLi1lueTh9mia4". You could put that password in an rspamd configuration file. But
cleartext passwords in configuration files are not quite elegant. Letâ€™s create a hash of the password:

```
rspamadm pw
Enter passphrase: â€¦
$2$icoahes75e7g9wxapnrbmqnpuzjoq7zâ€¦
```

Feed it the password that pwgen created for you and you will get a long hashed password. This procedure by the way is
also documented on the [rspamd pages](https://rspamd.com/doc/tutorials/quickstart.html#setting-the-controller-password).

Create a new configuration fileÂ `/etc/rspamd/local.d/worker-controller.inc` and put your hashed password in there:

```
password = "$2$icoahes75e7g9wxapnrbmqnpuzjoq7zâ€¦"
```

Thatâ€™s it for the configuration. Finally restart both rspamd and Apache to load your changed configuration:

```
systemctl restart rspamd
systemctl restart apache2
```

If everything went as expected you should now be able to access the rspamd web interface at
`https://webmail.example.org/rspamd`
