---
title: Sending / Relaying
lastUpdated: 2025-08-30
slug: ispmail-trixie/relaying
sidebar:
  order: 180
---

import { Aside } from "@astrojs/starlight/components";

Your mail server is almost ready for use. But one puzzle piece is missing. Your users can receive emails but they cannot
send them yet. This part of the guide is a bit longer than others because forwarding emails has security implications.
This is important to understand so don't skip it.

Let's begin with the difference of how **users** send emails versus how **mail servers** send emails. For comparison:

- A **mail server** fetches the _MX_ record for the destination domain of the recipient’s email address from DNS. That
  tells it which mail server to talk to. Then it opens an SMTP connection (TCP port 25) and sends the email.
- An **end user** with a mail client such as Thunderbird or Roundcube does not work that way. Mail clients do not
  include any functionality for fetching MX records. In addition, the user is usually on a dynamic IP address that other
  mail servers will not trust and will likely reject. Instead, end users are expected to send their emails through their
  provider’s (your) mail server: they authenticate with their login credentials and then send the message. This process
  is called relaying, because your mail server acts as an intermediary between the user and other mail servers on the
  internet. For security reasons, authentication is required before the user is allowed to send emails. Users are also
  expected to use the TCP port 587 which is called the _submission_ port. More on that later.

## SMTP versus Submission

Let's compare those services and ports side-by-side:

| Service name         | SMTP                        | Submission                   | Submissions           |
| -------------------- | --------------------------- | ---------------------------- | --------------------- |
| TCP Port             | 25                          | 587                          | 465                   |
| Transport encryption | **Off**. STARTTLS optional. | **Off**. STARTTLS mandatory. | TLS all the time      |
| Authentication       | Optional [^1]               | Mandatory                    | Mandatory             |
| Accepted sender      | Anyone                      | Our own users                | Our own users         |
| Accepted receivers   | Our own users               | Anyone                       | Anyone                |
| Meant for            | Servers                     | Our users                    | Our users             |
| Used by              | Mail transport agent (MTA)  | Mail user agent (MUA)        | Mail user agent (MUA) |
| Your home ISP        | may block this port         | will allow this port         | will allow this port  |

[^1]:
    In previous guides I recommended to set `smtpd_sasl_auth_enable=yes` globally in the `main.cf`. That would indeed
    enable authentication on port 25. For a clearer separation I now rather suggest to leave it out (default is `no`)
    and just enable authentication on the `submission` service in the `master.cf` file. A possible scenario that
    required this setting to be `on` would be if your server were a relay (_smarthost_) for other servers using
    authentication..

I hope this helps clarify the distinction. Human users must use the submission service on either port 587 or 465. The
key difference is that connections on port 587 start unencrypted, and the email client must issue the STARTTLS command
to enable encryption. In contrast, port 465 requires the email client to use TLS encryption right from the first byte of
communication.

## Configure the submission[s] services

All Postfix services are declared in the `/etc/postfix/master.cf` file. Most of them are used by Postfix internally,
like `pickup`, `cleanup`, `rewrite` or `bounce`. Let's add a new service for `submission` by running:

```sh
postconf -M submission/inet="submission inet n - y - - smtpd"
postconf -P "submission/inet/syslog_name=postfix/submission"
postconf -P "submission/inet/smtpd_tls_security_level=encrypt"
postconf -P "submission/inet/smtpd_sasl_auth_enable=yes"
postconf -P "submission/inet/smtpd_recipient_restrictions=permit_sasl_authenticated,reject"
postconf -P "submission/inet/smtpd_sender_restrictions=reject_sender_login_mismatch,permit_sasl_authenticated,reject"
```

That looked confusing, right? What it did was define the `submission` service in the `/etc/postfix/master.cf` service
for you using the `postconf` command. You could have achieved the same thing by editing that file and adding this
section:

```
submission inet  n       -       y       -       -       smtpd
  -o syslog_name=postfix/submission
  -o smtpd_tls_security_level=encrypt
  -o smtpd_sasl_auth_enable=yes
  -o smtpd_recipient_restrictions=permit_sasl_authenticated,reject
```

Some notes on that:

- Lines with options (`-o`) need to be indented so that Postfix understands that they belong to the same service.
- The word `submission` refers to the definition of the service in the `/etc/services` file. So it translates to TCP
  port 587.
- The `smtpd` at the end tells Postfix that connections should be handled as incoming SMTP connections.
- **syslog_name** is adding `postfix/submission` to log files so that you can distinguish it from other connections.
- **smtpd_sasl_auth_enable** enables authentication on this port. SASL is short for _Simple Authentication and Security
  Layer_.
- **smtpd_recipient_restrictions** define that only authenticated connections are permitted. Without a username and a
  password your connection will be rejected. The **recipient** keyword tells us that this restricts who the recipient
  can be.
- **smtpd_sender_restrictions** deals with the **sender**. I will explain that in the next section.

While you are at it, create the `submissions` (with an "s" at the end) service as well:

```sh
postconf -M submissions/inet="submissions inet n - y - - smtpd"
postconf -P "submissions/inet/syslog_name=postfix/submissions"
postconf -P "submissions/inet/smtpd_tls_wrappermode=yes"
postconf -P "submissions/inet/smtpd_sasl_auth_enable=yes"
postconf -P "submissions/inet/smtpd_recipient_restrictions=permit_sasl_authenticated,reject"
postconf -P "submissions/inet/smtpd_sender_restrictions=reject_sender_login_mismatch,permit_sasl_authenticated,reject"
```

The only difference to the `submission` (without the "s" at the end) is the `smtpd_tls_wrappermode` that switches on TLS
encryption right from the start of a connection.

## Enable encryption

We certainly do not want our users to send their password over the wire without encryption. So the following commands
enable encryption, set the key and certificate paths for Postfix. Just run these commands

<Aside type="danger" title="Important">

Please replace `mail.example.org` by the FQDN you chose.

</Aside>

```sh
postconf smtp_tls_security_level=may
postconf smtpd_tls_security_level=may
postconf smtpd_tls_cert_file=/etc/letsencrypt/live/mail.example.org/fullchain.pem
postconf smtpd_tls_key_file=/etc/letsencrypt/live/mail.example.org/privkey.pem
```

What it means:

- **smtp_tls_security_level**: \
  Allow encrypted _outgoing_ SMTP connections but do not enforce it.
- **smtpd_tls_security_level**: \
  Allow encrypted _incoming_ SMTP connections but do not enforce it.
- **smtpd_tls_cert_file** and **smtpd_tls_key_file**: \
  Where to find the private key and certificate for encryption.

Please note that configuration in `main.cf` applies to all Postfix services. So the above configuration enabled
encryption for both server-to-server and human-to-server (`submission`) services. The `smtpd_sasl_auth_enable` will only
be set for the `submission` service to enable authentication there.[^1]

<Aside type="tip" title="smtp or smtpd?">
  Look closely. Some settings start with `smtp_` and others start with with `smtpd_`. That is not a typo. `smtp_` refers
  to the SMTP _client_. That is the component that sends out emails **from** Postfix **to** other servers. Whereas
  `smtpd_` means the SMTP _server._ That in turn is the component that **receives** emails **from** other systems –
  either from a remote mail server or one of your users.
</Aside>

## Relaying

Feel free to send a test mail using the `submission` port and encryption (using STARTTLS):

```
swaks --server localhost:587 \
    --from john@example.org \
    --to lisa@example.com \
    -tls \
    --auth-user john@example.org \
    --auth-password summersun
```

Also give the `submissions` service a try:

```
swaks --server localhost:465 \
    --from john@example.org \
    --to lisa@example.com \
    --tls-on-connect \
    --auth-user john@example.org \
    --auth-password summersun
```

Did you notice the difference? This time we used port **465** and instead of the `-tls` option (which uses STARTTLS to
switch to encryption) we use `--tls-on-connect` that uses TLS right from from the start.

TODO: try sending from roundcube

Put simply, a mail server will accept an email if…

- it is responsible for handling mail for the recipient’s domain (the domain is listed as a virtual domain), or
- the sender has authenticated successfully with a valid username and password.

I have created two illustrations to explain it.

### Without authentication = denied

`john@example.org` is on the internet somewhere and wants to send an email to `lisa@example.com` (which is another
domain). Your mail server is not responsible for the _example.com_ domain so it receives John’s email and would have to
forward (relay) it to the actual mail server that is responsible for …@example.com email addresses. This may seem like a
harmless scenario but your mail server must deny that:

![Diagram that shows an outgoing unauthenticated email getting rejected](images/relaying-unauthenticated-relaying-denied.png)

Why? Because anyone can claim to be John and make your mail server forward mail. If an attacker (like a spammer) would
send millions of spam emails in John’s name through your server then other organisations will accuse *you* as the
operator of the mail server of spamming. Your mail server would be what people call an
_[open relay](https://en.wikipedia.org/wiki/Open_mail_relay)_. That is not what you want because your mail server would
get blacklisted and you will not be able to send out mail to most other servers. So without any proof that the sender is
indeed John, your server must reject the email.

Try for yourself:

```sh
swaks --server localhost:587 \
      --from john@example.org \
      --to list@example.com \
      -tls
```

TODO: submissions does not work yet

Towards the end of the output you will find:

```
 ~> MAIL FROM:<john@example.org>
<~  250 2.1.0 Ok
 ~> RCPT TO:<list@example.com>
<~* 554 5.7.1 <list@example.com>: Recipient address rejected: Access denied
```

### With authentication = accepted

So how does John prove his identity? He needs to use _authenticated_ SMTP. This is similar to the previous case but
John’s email program will also send his username and password.

![Diagram that shows an outgoing authenticated email getting relayed](images/relaying-authenticated-relaying.png)

We are making sure that his authentication happens over an encrypted connection so John’s password is safe.

Try for yourself and provide a valid user name and password:

```sh
swaks --server localhost:587 \
      --from john@example.org \
      --to list@example.com \
      -tls \
      --auth-user john@example.org \
      --auth-password summersun
```

Towards the end of the output you will find:

```
<~  250 2.0.0 Ok: queued as 7513F1F54B
```

You can even try a wrong password or a non-existing user. That should lead to…

```
<~* 535 5.7.8 Error: authentication failed: (reason unavailable)
```

TODO: a word on $mynetworks. Perhaps in the troubleshooting section later.

## Make Postfix use Dovecot for authentication

Enabling SMTP authentication in Postfix is surprisingly easy. You already configured Dovecot so it knows all about your
users from the SQL database. So let’s just make Postfix use that by telling it to ask the Dovecot server to verify the
username and password. Postfix just needs some extra configuration. Run these commands on the shell:

```
postconf smtpd_sasl_type=dovecot
postconf smtpd_sasl_path=private/dovecot-auth
```

This enables SMTP authentication and tells Postfix that it can talk to Dovecot through a socket file located at
`/var/spool/postfix/private/auth`. Do you remember that Postfix runs in a sandboxed *chroot* directory? That’s at
/var/spool/postfix. It cannot access any files outside of that directory. But fortunately in a previous section you
edited the /etc/dovecot/conf.d/10-master.conf file and made Dovecot place a socket file into
`/var/spool/postfix/private/auth` to allow communication from Postfix.

TODO: collapsible on anti-spoofing

## Protecting against forged sender addresses

At this stage, a security issue remains. While Postfix is configured to relay emails only after a successful login with
a valid username and password, it does not prevent an authenticated user from impersonating another sender. For example,
someone could log in as `john@example.org` but send an email appearing to come from `brunhilde@example.net`.

You want to see that this work? Let's pretend to be _brunhilde_ while authenticating as _john_:

```sh
swaks --server localhost:587 \
      --from brunhilde@example.org \
      --to list@example.com \
      -tls \
      --auth-user john@example.org \
      --auth-password summersun
```

That should not be allowed. But Postfix does not know better and responds with:

```
<~  250 2.0.0 Ok: queued as EEEB420F51
```

We should fix that. For that purpose Postfix provides a setting called
[smtpd_sender_login_maps](http://www.postfix.org/postconf.5.html#smtpd_sender_login_maps). From the "maps" part you can
deduce that it expects a _mapping_ again:

- _Question_: who you **claim** to be (email’s sender address)
- _Answer_: who you **logged in as** (user name after authentiation)

If you think of it, the mapping is simple. The _question_ must match the _answer_. If `john@example.org` wants to be the
sender, he must also authenticate as `john@example.org`.

As we use the email address also as a user name we simply need a mapping where the email address is listed on both
sides. Let's create it:

```sh
cat > /etc/postfix/mariadb-email2email.cf << EOF
user = mailserver
password = MAILSERVER-PASSWORD-HERE
hosts = 127.0.0.1
dbname = mailserver
query = SELECT email FROM virtual_users WHERE email='%s'
EOF

chown root:postfix /etc/postfix/mariadb-email2email.cf
chmod u=rw,g=r,o= /etc/postfix/mariadb-email2email.cf
```

Tell Postfix to use this mapping for our purpose:

```
postconf smtpd_sender_login_maps=mysql:/etc/postfix/mariadb-email2email.cf
```

You have already added `smtpd_sender_restrictions=reject_sender_login_mismatch` earlier in the master.cf for the
`submission` and `submissions` services. So you have achieved these three steps to prevent sender impersonation:

1. Create a mapping that matches an email address to itself.
2. Tell Postfix to use that mapping for `smtpd_sender_login_maps` which controls who can be a sender.
3. Enforce that restriction for the `submission` and `submissions` services.

You can now try to send email as a different user than you are logged in. Let’s us swaks again to send a spoofed email:

```sh
swaks --server localhost:587 \
     --from brunhilde@example.org \
     --to list@example.com \
     --tls \
     --auth-user john@example.org \
     --auth-password summersun
```

The server should rightfully reject that wrong sender:

```
~> MAIL FROM:john@example.com
<~ 250 2.1.0 Ok
~> RCPT TO:john@example.org
<~ * 553 5.7.1 john@example.com: Sender address rejected: not owned by user john@example.org
```

You can also see that restriction in action by adding a fake persona in Roundcube and try to use it. In
Settings/Identities you can create another sender email address as in:

![Selecting another identity in Roundcube](images/relaying-roundcube-selecting-identity.png)

With this wrong sender address any email should get rejected. Roundcube will show you an error that is generated by
Postfix:

```
553 5.7.1 <someoneelse@example.com>:
Sender address rejected:
not owned by user john@example.org
```

<Aside type="tip" title="Allow aliases?">
  If you want to allow users to send as one of their aliases you could create a new \*.cf file with a mapping query like
  this: `SELECT email FROM virtual_users WHERE email='%s' UNION SELECT destination FROM virtual_aliases WHERE
  source='%s'`
</Aside>

## How does authentication work?

<details class="collapsible">
  <summary>Click here if you want to learn how SMTP authentication works…</summary>

Are you curious how SMTP authentication looks on a low level? You probably are not. But let’s do it anyway. Just once,
so that you get the idea.

```
telnet localhost submission
```

The server will let you in:

```
Trying 127.0.0.1…
Connected to localhost.
Escape character is '^\]'.
220 webmail ESMTP Postfix (Debian/GNU)
```

Say hello:

```
ehlo example.com
```

Postfix will present a list of features that are available for you:

```
250-mailtest
250-PIPELINING
250-SIZE 10240000
250-VRFY
250-ETRN
250-STARTTLS
250-ENHANCEDSTATUSCODES
250-8BITMIME
250-DSN
250-SMTPUTF8
250 CHUNKING
```

Let me briefly explain what these lines mean:

- PIPELINING  
   This is a feature to speed up SMTP communication. Usually the remote system has to wait for a response to every command
  it sends. Pipelining allows the remote server to send several commands in a batch without waiting for a response. Postfix
  will just store these commands and execute them one by one. If you told Postfix to forbid pipelining it would disconnect
  the remote server when it tries to send bulks of commands without waiting for the proper reply. It is mainly a feature
  against rogue senders.
- SIZE 10240000  
   The remote server is allowed to send emails up to 10 MB large. This has long been a common maximum size for emails. However
  nowadays 40 MB or even more are more common sizes because emails have grown larger. Some mail servers even allow 100 MB.
- VRFY  
   Allows remote servers to verify a given name or email address. For example the remote server could send "VRFY john" and
  your server might respond `250 John Doe <john@example.org>`. It can be used to verify that a certain recipient email address
  is deliverable
- ETRN  
   A command that a remote system can send to flush the Postfix queue of mails for a certain domain. It can be used if the
  remote system had technical problems and failed to receive email for a while. Then it could send an ETRN command to make
  your server start sending outstanding emails for that domain. It is rarely used.
- STARTTLS  
   This tells the remote system that it might start switching from this unencrypted to an encrypted connection by sending
  the "STARTTLS" command. It will then start negotiating a TLS-encrypted connection. You could compare it to an HTTP connection
  that suddenly switches over to an encrypted HTTPS connection. The advantage is that you can start talking SMTP on TCP port
  25 and don’t have to open up a second TCP port like 465 which is the "SSMTP" (secure SMTP) port and only accepts encrypted
  connections.
- ENHANCEDSTATUSCODES  
   This enables more three-digit return codes for various conditions. See the [RFC2034](http://tools.ietf.org/html/rfc2034)
  if you are curious.
- 8BITMIME  
   In ancient times SMTP only processed 7-bit characters. You couldn’t transfer special characters like "Ä" or "ß" without
  special encoding. 8BITMIME allows a transmission of emails using 8-bit characters. Still many emails are specially encoded
  using ISO8859-1 or UTF-8.
- DSN  
   It enables DSNs (delivery status notofications) that allows the sender to control the messages that Postfix creates when
  an email could not be delivered as intended.
- SMTPUTF8  
   In addition to 8BITMIME you can use UTF8 encoded characters in header fields.
- CHUNKING  
   This feature (described in [RFC 3030](https://tools.ietf.org/html/rfc3030)) makes sending of large emails more efficient.

However one important line is missing here that would allow us to send our username and password:

```
250-AUTH PLAIN LOGIN
```

We told Postfix to only allow authentication when the connection is encrypted. So we are not offered authentication over
this plain text connection. That’s what we want.

Are you still connected? Okay, good. So we need an encrypted connection using TLS. Using the STARTTLS feature we can
switch over from unencrypted to encrypted without having to reconnect. Enter…

```
STARTTLS
```

And the server replies:

```
220 2.0.0 Ready to start TLS
```

However now it’s getting weird because you would have to speak TLS encryption which is not a language that humans speak.
So let’s quit this using the "QUIT" command and do that differently:

```
QUIT
```

We can use OpenSSL to help us with the decryption. Run:

```
openssl s_client -connect localhost:25 -starttls smtp
```

You will see a lot of output. OpenSSL has connected to TCP port 25 and issued a STARTTLS command to switch to an
encrypted connection. So whatever you type now will get encrypted. Enter:

```
EHLO example.com
```

And Postfix will send a list of capabilities that will look like this:

```
250-PIPELINING
250-SIZE 10240000
250-VRFY
250-ETRN
250-AUTH PLAIN LOGIN
250-ENHANCEDSTATUSCODES
250-8BITMIME
250 DSN
```

And now that we are using an encrypted connection Postfix offers us to authenticate. So let us send the authentication
string with a Base64-encoded password:

```
AUTH PLAIN AGpvaG5AZXhhbXBsZS5vcmcAc3VtbWVyc3Vu
```

Unless you have changed John’s password to something else than "summersun" the server should accept that authentication:

```
235 2.7.0 Authentication successful
```

Excellent. You are logged in through SMTP. You could now send an email to be forwarded to another mail server. I just
wanted to show that authentication works if you use an encrypted connection.

Disconnect from Postfix:

```
QUIT
```

Authentication works. Well done.

Wait a minute. What was that crazy cryptic string? There was no username and password in it. Was it encrypted?

No, that was no encryption. It was merely an _encoded_ version of the username and password. Why that? Well usually in
SMTP you can only transfer ASCII characters. But the password may contain special characters which are not covered by
ASCII. So in the _PLAIN_ method that information is [Base64](https://en.wikipedia.org/wiki/Base64) encoded.

What is actually converted to Base64…

```
NULL-BYTE + USERNAME + NULL-BYTE + PASSWORD
```

So for John’s case you can easily create the Base64 string using:

```
printf '\0john@example.org\0summersun' | base64
```

As a result you will get the exact same string you used above with "AUTH PLAIN".

TODO: move further down

</details>
